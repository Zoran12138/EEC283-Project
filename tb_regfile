// Testbench for regfile.sv: clock, golden_mem, directed tests, self-check.
//------------------------------------------------------------------------------
`timescale 1ns/1ps

module tb_regfile;

  // parameters
  localparam int WIDTH = 32;
  localparam int DEPTH = 32;

  // signals
  logic                   clk;
  logic                   we;
  logic [$clog2(DEPTH)-1:0] waddr;
  logic [WIDTH-1:0]       wdata;
  logic [$clog2(DEPTH)-1:0] raddr1, raddr2;
  logic [WIDTH-1:0]       rdata1, rdata2;

  // Instantiate DUT
  regfile #(.WIDTH(WIDTH), .DEPTH(DEPTH)) dut (
    .clk   (clk),
    .we    (we),
    .waddr (waddr),
    .wdata (wdata),
    .raddr1(raddr1),
    .raddr2(raddr2),
    .rdata1(rdata1),
    .rdata2(rdata2)
  );

  // Golden reference model
  logic [WIDTH-1:0] golden_mem [0:DEPTH-1];

  // clock generation: 10 ns period
  initial clk = 0;
  always #5 clk = ~clk;

  // initialize
  initial begin
    we      = 0;
    waddr   = 0;
    wdata   = '0;
    raddr1  = 0;
    raddr2  = 0;
    // zero out golden
    for (int i = 0; i < DEPTH; i++) golden_mem[i] = '0;
    #10;
  end

  // Drive golden model on writes
  always_ff @(posedge clk) begin
    if (we && waddr != '0) begin
      golden_mem[waddr] <= wdata;
    end
  end

  // Checker: on each read cycle compare DUT vs golden
  always_ff @(posedge clk) begin
    // only check when not writing (so reads settle)
    if (!we) begin
      // port1
      if (raddr1 != '0 && rdata1 !== golden_mem[raddr1]) begin
        $error("Mismatch @ rdata1: addr=%0d dut=%h gold=%h",
               raddr1, rdata1, golden_mem[raddr1]);
      end
      // port2
      if (raddr2 != '0 && rdata2 !== golden_mem[raddr2]) begin
        $error("Mismatch @ rdata2: addr=%0d dut=%h gold=%h",
               raddr2, rdata2, golden_mem[raddr2]);
      end
    end
  end

  // Directed test sequence
  initial begin
    #20;
    $display("=== Directed tests start ===");

    // Test 1: write to x0 should have no effect
    we     = 1; waddr = 0; wdata = 32'hDEAD_BEEF; #10;
    we     = 0; raddr1 = 0; #10;
    $display("Read x0 = %h (expect 0)", rdata1);

    // Test 2: simple write-read
    we     = 1; waddr = 5; wdata = 32'h1234_ABCD; #10;
    we     = 0; raddr1 = 5; #10;
    $display("Read [5] = %h (expect 1234_ABCD)", rdata1);

    // Test 3: same-cycle write & read
    we     = 1; waddr = 7; wdata = 32'hCAFEBABE;
    raddr1 = 7; raddr2 = 7; #10;
    we     = 0; 
    $display("RW collision: r1=%h, r2=%h (expect CAFEBABE)", rdata1, rdata2);

    // Test 4: multi-cycle writes to same address
    we     = 1; waddr = 10; wdata = 32'hAAAAAAAA; #10;
             wdata = 32'h55555555; #10;
    we     = 0; raddr1 = 10; #10;
    $display("Multi-write: r1=%h (expect 55555555)", rdata1);

    $display("=== Directed tests done ===");
    $finish;
  end

endmodule
